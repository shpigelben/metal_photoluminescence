{"path":"4. Misc/NM - HW8 - Jupyter Notebook.pdf","text":"5/25/2021 NM - HW8 - Jupyter Notebook localhost:8888/notebooks/iCloudDrive/Studies/8th Semester/Computational Methods/NM - HW/NM - HW8/NM - HW8.ipynb 1 /9 NM - HW8 The probability to choose a random direction, using spherical coordinates (on a unit sphere), is given by 1 = ğ‘ƒ (ğœƒ, ğœ™) = ğ‘ ğ‘–ğ‘›(ğœƒ)ğ‘‘ğœƒğ‘‘ğœ™ = [ğ‘Ÿ = 1] = ( ğ‘ ğ‘–ğ‘›(ğœƒ)ğ‘‘ğœƒ ) ( ğ‘‘ğœ™ ) = ğ‘(ğœƒ)ğ‘(ğœ™) âˆ¬Î© âˆ¬Î© ğ‘Ÿ2 âˆ« ğœ‹ 0 âˆ« 2ğœ‹ 0 (1) can be sampled uniformly from 1 = (ğœ™) = ğ‘ ğ‘‘ğœ™ = 2ğœ‹ğ‘ â†’ ğ‘(ğœ™) = âˆ« 2ğœ‹ 0 ğ‘ ÌƒÂ  âˆ« 2ğœ‹ 0 1 2ğœ‹ (2) ğ‘(ğœ™) [0, 2ğœ‹] is not distributed uniformly on and will be sampled inversly 1 = (ğœƒ) = ğ‘ ğ‘ ğ‘–ğ‘›(ğœƒ)ğ‘‘ğœƒ = 2ğ‘ â†’ ğ‘(ğœƒ) = ğ‘ ğ‘–ğ‘›(ğœƒ) âˆ« ğœ‹ 0 ğ‘ ÌƒÂ  âˆ« ğœ‹ 0 1 2 (3) ğ‘(ğœƒ) [0, ğœ‹] and now we sample uniformly from ğ‘ƒ (ğœƒ) = ğ‘ ğ‘–ğ‘›( )ğ‘‘ = (1 âˆ’ cos(ğœƒ)) â†’ ğœƒ(ğ‘ƒ ) = arccos (1 âˆ’ 2ğ‘ƒ ) âˆ« ğœƒ 0 1 2 ğœƒ â€² ğœƒ â€² 1 2 (4) ğ‘ƒ [0, 1] In [1]: Step lengths are distributed exponentially ğ‘(ğ¿) = Â Â Â  âŸ¶ Â Â Â ğ‘ƒ (ğ¿) = ğ‘‘ = 1 âˆ’ 1 ğœ† ğ‘’ âˆ’ ğ¿ ğœ† âˆ« ğ¿ 0 1 ğœ† ğ‘’ âˆ’ ğ¿â€² ğœ† ğ¿â€² ğ‘’ âˆ’ ğ¿ ğœ† (5) ğ¿(ğ‘ƒ ) = ğœ† ln ( ) ; ğ‘ƒ âˆˆ [0, 1] 1 1 âˆ’ ğ‘ƒ (6) import numpy as np import matplotlib . pyplot as plt def RandDir (): \"\"\" returns a random, uniformly distributed unit vector e = [e1, e2, e3] \"\"\" phi = np . random . random ( 1 ) * 2 * np . pi theta = np . arccos ( 1 - 2 * np . random . random ( 1 )) e = np . zeros ([ 3 ]) e [ 0 ] = np . sin ( theta ) * np . cos ( phi ) e [ 1 ] = np . sin ( theta ) * np . sin ( phi ) e [ 2 ] = np . cos ( theta ) return e 123456789 1011121314151617 5/25/2021 NM - HW8 - Jupyter Notebook localhost:8888/notebooks/iCloudDrive/Studies/8th Semester/Computational Methods/NM - HW/NM - HW8/NM - HW8.ipynb 2 /9 In [2]: def RandWalkExp3D ( p , Lambda , N ): \"\"\" RandWalkExp3D (starting point, mean free path 'lambda', number of steps ) \"\"\" position = np . zeros ([ N , 3 ]) ## position ## (x1,y1,z1) ## (x2,y2,z2) ## . ## . ## (xN,yN,zN) for i in range ( 0 , N - 1 ): L = Lambda * np . log ( 1 / ( 1 - np . random . random ( 1 )) ) p = p + L * RandDir () position [ i + 1 ] = p return position p0 = [ 1 , 2 , 3 ] y = RandWalkExp3D ( p0 , 1 , 300 ) fig = plt . figure ( figsize = [ 10 , 10 ]) ax = fig . add_subplot ( 111 , projection = '3d' ) ax . plot ( y [:, 0 ], y [:, 1 ], y [:, 2 ], 'o-' ) plt . show () def RandomStep ( p , Lambda ): \"\"\" Takes a 3D point and moves in a random direction, according to exponential probability and a given mean free path. Returns the 3D point after the random walk. \"\"\" L = Lambda * np . log ( 1 / ( 1 - np . random . random ( 1 )) ) p = p + L * RandDir () return p 123456789 10111213141516171819202122232425262728293031323334353637383940 5/25/2021 NM - HW8 - Jupyter Notebook localhost:8888/notebooks/iCloudDrive/Studies/8th Semester/Computational Methods/NM - HW/NM - HW8/NM - HW8.ipynb 3 /9 1 .2 Let's define g as a function that receives a position array 5/25/2021 NM - HW8 - Jupyter Notebook localhost:8888/notebooks/iCloudDrive/Studies/8th Semester/Computational Methods/NM - HW/NM - HW8/NM - HW8.ipynb 4 /9 In [3]: 1 .3 Out[3]: [[0.1, 0.1, 0.1], [0.1, 0.1, 0.1], [0.1, 0.1, 0.1]] def gcube ( M ): \"\"\" receives Nx3 array of positions and returns N'x3 array of N' position that are inside g \"\"\" MM = [] for i in range ( len ( M )): if abs ( M [ i ][ 0 ]) < 1 and abs ( M [ i ][ 1 ]) < 1 and abs ( M [ i ][ 2 ]) < 1 : MM . append ( M [ i ]) return MM A = [ [ 0.1 , 0.1 , 0.1 ], [ 0.1 , 2.0 , 0.1 ], [ 0.1 , 0.1 , 0.1 ], [ 2.0 , 0.1 , 0.1 ], [ 0.1 , 0.1 , 0.1 ] , [ 3.0 , gcube ( A ) 123456789 101112131415 5/25/2021 NM - HW8 - Jupyter Notebook localhost:8888/notebooks/iCloudDrive/Studies/8th Semester/Computational Methods/NM - HW/NM - HW8/NM - HW8.ipynb 5 /9 In [4]: 1 .4 def RandomStep ( p , Lambda ): \"\"\" Takes a 3D point and moves in a random direction, according to exponential probability and a given mean free path. Returns the 3D point after the random walk. \"\"\" L = Lambda * np . log ( 1 / ( 1 - np . random . random ( 1 )) ) p = p + L * RandDir () return p def NeutronInit ( N ): M1 = np . random . uniform ( - 1 , 1 , [ N , 3 ]) return M1 def NeutronSimulate ( N , g , Lambda , k , steps ): # initialization M1 = NeutronInit ( N ) for i in range ( steps ): # random step for j in range ( len ( M1 )): M1 [ j ] = RandomStep ( M1 [ j ], Lambda ) # elimination M1 = g ( M1 ) # fission for t in range ( len ( M1 )): if np . random . random () < k : M1 . append ( M1 [ t ]) M1 = np . array ( M1 ) return M1 M2 = NeutronSimulate ( 50 , gcube , 0.4 , 0.3 , 30 ) 123456789 101112131415161718192021222324252627282930313233343536373839 5/25/2021 NM - HW8 - Jupyter Notebook localhost:8888/notebooks/iCloudDrive/Studies/8th Semester/Computational Methods/NM - HW/NM - HW8/NM - HW8.ipynb 6 /9 In [5]: def gsphere ( M ): \"\"\" receives Nx3 array of positions and returns N'x3 array of N' position that are inside g \"\"\" MM = [] for i in range ( len ( M )): if np . sqrt ( ( M [ i ][ 0 ]) ** 2 + ( M [ i ][ 1 ]) ** 2 + ( M [ i ][ 2 ]) ** 2 ) < 1 : MM . append ( M [ i ]) return MM 123456789 10111213 5/25/2021 NM - HW8 - Jupyter Notebook localhost:8888/notebooks/iCloudDrive/Studies/8th Semester/Computational Methods/NM - HW/NM - HW8/NM - HW8.ipynb 7 /9 In [87]: % matplotlib inline fig = plt . figure ( figsize = [ 10 , 10 ]) ax = fig . add_subplot ( 111 , projection = '3d' ) A = [ 4 / 6 , 4 / 7 , 4 / 8 , 4 / 9 , 4 / 10 , 4 / 11 , 4 / 12 ] B = [ 4 / 9 , 4 / 10 , 4 / 11 , 4 / 12 ] for i in A : P1 = NeutronSimulate ( 100 , gsphere , i , 0.3 , 50 ) if len ( P1 ) != 0 : ax . scatter ( P1 [:, 0 ], P1 [:, 1 ], P1 [:, 2 ], 'o-' , label = i ) plt . legend () plt . show () # for i in A:# P2 = NeutronSimulate(100 , gcube , 0.2*i , 0.5, 10)# if len(P2) != 0:# ax.scatter(P2[:,0],P2[:,1],P2[:,2], 'o-', label = i)# plt.legend() # plt.show() 123456789 101112131415161718192021 5/25/2021 NM - HW8 - Jupyter Notebook localhost:8888/notebooks/iCloudDrive/Studies/8th Semester/Computational Methods/NM - HW/NM - HW8/NM - HW8.ipynb 8 /9 In [53]: In [68]: In [81]: Out[53]: 58.018933126496286 uranium_density = 19 #g/cm^3 Rc = 9 #cm Vc = ( 4 / 3 ) * np . pi * Rc ** 3 #cm^3 Mc = Vc * uranium_density #g Mc_kg = Mc / 1000 Mc_kg Vsphere = [[],[],[],[],[],[],[]] Vcube = [[],[],[],[],[],[],[]] N = 10 for i in range ( len ( A )): for j in range ( N ): Vsphere [ i ]. append ( len ( NeutronSimulate ( 100 , gsphere , A [ i ] , 0.3 , 50 )) ) Vcube [ i ]. append ( len ( NeutronSimulate ( 100 , gcube , A [ i ] , 0.3 , 50 )) ) VsphereMean = [] VsphereStd = [] VcubeMean = [] VcubeStd = [] for i in range ( 7 ): VsphereMean . append ( np . mean ( Vsphere [ i ]) ) VsphereStd . append ( np . std ( Vsphere [ i ]) ) VcubeMean . append ( np . mean ( Vcube [ i ]) ) VcubeStd . append ( np . std ( Vcube [ i ]) ) plt . plot ( A , VsphereMean , label = \"sphere\" ) plt . plot ( A , VcubeMean , label = \"cube\" ) plt . ylabel ( \"# of neutrons in g\" ) plt . xlabel ( \"$ \\\\lambda R^{-1} $\" ) plt . legend () plt . show () 123456 1234567 123456789 10111213141516 5/25/2021 NM - HW8 - Jupyter Notebook localhost:8888/notebooks/iCloudDrive/Studies/8th Semester/Computational Methods/NM - HW/NM - HW8/NM - HW8.ipynb 9 /9 It is apparent that the \"explosion\" of neutrons occurs at a larger scale for the cube than it is for the sphere for the sphere it occurs ar aorund 0.40 which is R = 10cm for the cube is occurs at less than 0.35 which is R = 1 1.42cm ğ‘ğ‘šâˆ’1 ğ‘ğ‘šâˆ’1","libVersion":"0.5.0","langs":""}